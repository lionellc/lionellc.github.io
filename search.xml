<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript深入之从原型到原型链]]></title>
    <url>%2F2018%2F12%2F17%2FdeepJs1%2F</url>
    <content type="text"><![CDATA[本文来自：JavaScript深入之从原型到原型链 构造函数创建对象我们先使用构造函数创建一个对象：1 2 3 4 function Person() &#123;&#125; var person = new Person(); person.name = &apos;Lionel&apos;; console.log(person.name) // Lionel 在这个列子中，Person就是一个构造函数，我们使用new创建了一个实例对象person。 很简单吧，接下来进入正题： prototype每个函数都有一个prototype属性，就是我们经常在各种例子中看到的那个prototype，比如： 1 2 3 4 5 6 function Person()&#123;&#125; // prototype是函数才会有的属性 Person.prototype.name = &apos;Lionel&apos; var person1 = new Person() var person2 = new Person() console.log(person1.name, person2.name) // Lionel, Lionel 那这个函数的prototype属性到底指向的是什么呢？是这个函数的原型吗？ 其实，函数的prototype属性指向了一个对象，这个对象正是调用该构造函数而创建的的实例的原型，也就是这个例子中的person1和person2的原型。 那什么是原型呢？你可以这样理解：每一个JS对象(null除外)，在创建的时候就会与之关联另一对象，这个对象就是我们所说的原型，每一个对象都会从原型“继承”属性。 让我们用一张图标识构造函数和实例原型之间的关系：在这张图中我们用Object.prototype表示实例原型。 那么我们该怎么表示实例与实例原型，也就是person和Person.prototype之间的关系呢，这个时候我们就要讲到第二个属性： proto这是每一个JS对象(除了null)都具有的一个属性，叫__proto__,这个属性会指向该对象的原型。未来证明这一点，我们可以在调试台中输入： 1 2 3 4 5 function Person() &#123; &#125; var person = new Person() console.log(person.__proto__ === Person.prototype) // true 于是我们更新下关系图：既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？ constructor指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个constructor属性指向关联的构造函数。 为了验证这一点，我们可以尝试：1 2 function Person()&#123;&#125; console.log(Person === Person.prototype.constructor); // true 所以再更新下关系图：综上我们已经得出： 1 2 3 4 5 6 function Person()&#123;&#125; var person = new Person(); console.log(person.__proto__ == Person.prototype) // true console.log(Person.prototype.constructor == Person) // true // 顺便学习一个ES5方法，可以获得对象的原型 console.log(Object.getPrototypeOf(person) === Person.prototype) // true 了解了构造函数、实例原型和实例之间的关系，接下来我们讲讲实例和原型的关系： 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。 举个例子： 1 2 3 4 5 6 7 8 function Person() &#123;&#125; Person.prototype.name = &apos;Lionel&apos; var person = new Person() person.name = &apos;Karma&apos;; console.log(person.name) // Karma delete person.name console.log(person.name) // Lionel 如果在原型中没有找到属性呢？原型的原型又是什么呢？ 原型的原型在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：1 2 3 var obj = new Object(); obj.name = &apos;Lionel&apos; console.log(obj.name) // Lionel 其实原型对象就是通过Object构造函数生成的，结合之前所讲，实例的__proto__指向构造函数的prototype，所以我们再更新下关系图： 原型链那Object.prototype的原型呢？null，我们可以打印：1 console.log(Object.prototype.__proto__ === null) // true 然而null究竟代表了什么呢？引用阮一峰老师的《undefined与null的区别》就是： null表示“没有对象”，即该处不应该有值。所以Object.prototype.__proto__的值为null跟Object.prototype没有原型，其实表达了一个意思。所以查找属性的时候查到Object.prototype就可以停止查找了。最后一张关系图也可以更新为： 顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。 补充最后，补充三点大家可能不会注意的地方： constructor 首先是constructor属性，我们看个例子： 1 2 3 function Person() &#123;&#125; var person = new Person(); console.log(person.constructor === Person) // true 当获取person.constructor时，其实person中并没有constructor属性，当不能读取到constructor属性时，会从person的原型也就是Person.prototype中读取，正好原型中有该属性，所以：1 person.constructor === Person.prototype.constructor proto 其次是__proto_-，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于Person.prototype中，实际上，它是来自于Object.prototype，与其说是一个属性，不如说是一个getter/setter，当使用obj.__proto__时，可以理解成返回了Object.getPrototypeOf(obj)。 真的是继承吗？ 最后是关于继承，前面我们讲到“每一个对象都会从原型’继承’属性”，实际上，继承是一个十分具有迷惑性说法，引用《你不知道的JavaScript》中的话，就是： 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>深入系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结合源码理解vue生命周期]]></title>
    <url>%2F2018%2F11%2F20%2Fvue-lifecycle%2F</url>
    <content type="text"><![CDATA[1.何为生命周期简单理解，vue中的生命周期指的是一个vue实例从开始创建到最后被销毁所经历的整个过程，这个过程包括了设置数据监听，编译模版，将实例挂载到DOM，数据发生变化时更新DOM，销毁一个vue实例等阶段。 2.生命周期图示下图是官方给出的生命周期图示，本文将以此图结合源码进行解读。 3.生命周期的各个阶段在开始之前，我们先从vue的构造函数开始进行源码的解读，在此用的是尤大8月份刚刚发布的2.5.17版本，相关的代码在core/instance/index.js下面，代码不多，基本可以自己理解。1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //这里跟Babel转码ES6的Class有异曲同工之妙，感兴趣的小伙伴可以自己去了解以下Babel如何转码Class的 function Vue (options) &#123; if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !(this instanceof Vue) ) &#123; warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;) &#125; this._init(options) &#125; initMixin(Vue) stateMixin(Vue) eventsMixin(Vue) lifecycleMixin(Vue) renderMixin(Vue) 1.beforeCreate之前在上一段代码中，我们先从this._init(options)开始看起，在此阶段实例vm实例还没有被创建，主要进行一些vm实例创建前的初始化的工作，下面是相关源码，由于代码太长，只贴了相关的代码。1 2 3 4 5 6 7 8 initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, &apos;beforeCreate&apos;) initInjections(vm) // resolve injections before data/props initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, &apos;created&apos;) 我们先重点关注以下这几行代码：1 2 3 4 initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, &apos;beforeCreate&apos;) 可以很明显的看出来，在beforeCreate这个钩子函数调用之前做了三件事情，下面让我们看看这三行代码到底执行了什么操作，先看第一行，initLifecycle(vm)。进入这个函数，可以看出来，这个函数的主要作用是初始化vm对象，给这个对象增加了一些属性等工作。1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 export function initLifecycle (vm: Component) &#123; const options = vm.$options // locate first non-abstract parent let parent = options.parent if (parent &amp;&amp; !options.abstract) &#123; while (parent.$options.abstract &amp;&amp; parent.$parent) &#123; parent = parent.$parent &#125; parent.$children.push(vm) &#125; vm.$parent = parent vm.$root = parent ? parent.$root : vm vm.$children = [] vm.$refs = &#123;&#125; vm._watcher = null vm._inactive = null vm._directInactive = false vm._isMounted = false vm._isDestroyed = false vm._isBeingDestroyed = false &#125; 接下来我们看initEvents(vm)执行了什么操作，可以看出现在vm实例上创建了事件对象，用来存放事件，并且创建了一个是否有钩子事件的bool标志位，之后初始化了父组件attached的方法，这个地方跟父子组件间通讯有关，在这里就不详细展开了。1 2 3 4 5 6 7 8 9 export function initEvents (vm: Component) &#123; vm._events = Object.create(null) vm._hasHookEvent = false // init parent attached events const listeners = vm.$options._parentListeners if (listeners) &#123; updateComponentListeners(vm, listeners) &#125; &#125; 我们继续看代码initRender(vm)，代码如下，可以看的出来这里也是做了一些初始化的工作，只不过是为渲染做的准备，包括初始化vnode等。由此总的来说，在beforeCreate之前的这个阶段，主要进行的工作是初始化，只不过针对vm对象，事件，Render分别做了初始化而已，初始化结束，就可以执行我们的钩子函数beforeCreate了，从实际开发角度来讲，可以在beforeCreate执行一些show loading的动作等。1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 export function initRender (vm: Component) &#123; vm._vnode = null // the root of the child tree vm._staticTrees = null // v-once cached trees const options = vm.$options const parentVnode = vm.$vnode = options._parentVnode // the placeholder node in parent tree const renderContext = parentVnode &amp;&amp; parentVnode.context vm.$slots = resolveSlots(options._renderChildren, renderContext) vm.$scopedSlots = emptyObject // bind the createElement fn to this instance // so that we get proper render context inside it. // args order: tag, data, children, normalizationType, alwaysNormalize // internal version is used by render functions compiled from templates vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false) // normalization is always applied for the public version, used in // user-written render functions. vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true) // $attrs &amp; $listeners are exposed for easier HOC creation. // they need to be reactive so that HOCs using them are always updated const parentData = parentVnode &amp;&amp; parentVnode.data /* istanbul ignore else */ if (process.env.NODE_ENV !== &apos;production&apos;) &#123; defineReactive(vm, &apos;$attrs&apos;, parentData &amp;&amp; parentData.attrs || emptyObject, () =&gt; &#123; !isUpdatingChildComponent &amp;&amp; warn(`$attrs is readonly.`, vm) &#125;, true) defineReactive(vm, &apos;$listeners&apos;, options._parentListeners || emptyObject, () =&gt; &#123; !isUpdatingChildComponent &amp;&amp; warn(`$listeners is readonly.`, vm) &#125;, true) &#125; else &#123; defineReactive(vm, &apos;$attrs&apos;, parentData &amp;&amp; parentData.attrs || emptyObject, null, true) defineReactive(vm, &apos;$listeners&apos;, options._parentListeners || emptyObject, null, true) &#125; &#125; 2.beforeCreate之后，created之前这一部分官方给出的生命周期图示中描述的是Init injection &amp; reactivity, 但从字面意思来看，似乎也是初始化相关的工作，那我们来看代码吧，这一部分代码紧跟在beforeCreate钩子函数之后，还是比较清楚的。1 2 3 4 initInjections(vm) // resolve injections before data/props initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, &apos;created&apos;) 这里的initInjections(vm)和initProvide(vm)是在2.2.0新增的选项，放在一起的说明的原因是这对选项要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效，可以简单理解为新增加了一种父子组件间的通信方式，但是由于官方提供这两个选项主要是为了高阶插件/组件库提供用例，并不推荐直接用于程序代码中，此处就不贴源码解读了。 重点看一下initState(vm)，用vue进行过开发的人可能对下面代码比较熟悉了，这里主要是对props、methods、data、computed、watch的一些初始化，这些属性都是在平时开发中用到的比较多的，所以在执行ceated的时候，这些数据是可以拿到的。1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 export function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) if (opts.data) &#123; initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125; &#125; 3.created之后，beforeMount之前从图示来看，这一段做的事情比较多，但是主要跟DOM渲染有关。在_init函数中，当执行完callHook(vm, &#39;created&#39;)之后，可以看到以下代码。1 2 3 if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125; 这里对vm中的el做了一个判断，如果el不存在，那生命周期到这里就结束了，直到开发者手动用$mount去挂载el。如果el存在，那我们继续看$mount函数都做了啥。1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 const mount = Vue.prototype.$mount Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean ): Component &#123; el = el &amp;&amp; query(el) ... const options = this.$options // resolve template/el and convert to render function if (!options.render) &#123; let template = options.template if (template) &#123; if (typeof template === &apos;string&apos;) &#123; if (template.charAt(0) === &apos;#&apos;) &#123; template = idToTemplate(template) /* istanbul ignore if */ if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !template) &#123; warn( `Template element not found or is empty: $&#123;options.template&#125;`, this ) &#125; &#125; &#125; else if (template.nodeType) &#123; template = template.innerHTML &#125; else &#123; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; warn(&apos;invalid template option:&apos; + template, this) &#125; return this &#125; &#125; else if (el) &#123; template = getOuterHTML(el) &#125; if (template) &#123; /* istanbul ignore if */ if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123; mark(&apos;compile&apos;) &#125; const &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123; shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments &#125;, this) options.render = render options.staticRenderFns = staticRenderFns /* istanbul ignore if */ if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123; mark(&apos;compile end&apos;) measure(`vue $&#123;this._name&#125; compile`, &apos;compile&apos;, &apos;compile end&apos;) &#125; &#125; &#125; return mount.call(this, el, hydrating) &#125; $mount方法是直接定义在Vue的prototype上的，注意第一行代码把Vue.prototype.$mount赋值给了mount，并且在代码的最后又执行了mount，之后我们再解释这是为什么。下面这段代码是在entry-runtime-with-compiler.js中，可以通过config.js和alias.js找到这个文件。我们看一下这个$mount函数都干了什么。我们只看比较重要的部分，首先对vm中有没有render函数做了一个判断，所以来说对于render函数，template和outerHTML这三者来说，render函数应该是最高的，其次是template，最后才是outerHTMl。最后执行compileToFunctions()函数将模板template解析成render函数，同时可以看出，如果template不存在的话，那会执行getOuterHTML(el)，所以也比较好理解为什么要在之前判断有没有el了，因为当template不存在时要拿el去取outerhtml。 回答之前我们提出的问题，为什么第一行代码把Vue.prototype.$mount赋值给了mount，在这里要解释一下Vue的构建版本问题，官方给出的解释是这样的，开发者既可以使用运行时+编译器版本，也可以只使用运行时版本，如果使用运行时版本的话那就不能使用template选项，自然$mount也就不一样了。当使用 vue-loader 或 vueify 的时候，*.vue文件内部的模板会在构建时预编译成 JavaScript。你在最终打好的包里实际上是不需要编译器的，所以只用运行时版本即可。所以当我们运行完整版的时候，两处定义的$mount都会执行，这里用mount暂存之前的Vue.prototype.$mount是为了之后继续执行这一部分代码。 完整版：同时包含编译器和运行时的版本。编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码。运行时：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切 接下来我们继续看mount.call(this, el, hydrating)是如何执行的。代码很简单，直接执行了mountComponent(this, el, hydrating)。1 2 3 4 5 6 7 Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean ): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating) &#125; 那我们继续跟进，看一下mountComponent, 这里callHook(vm, &#39;beforeMount&#39;)被调用了，至此，created之后，beforeMount之前这个阶段结束，可以看得出来，vue在这一阶段主要进行的就是渲染方面的工作。1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 export function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean ): Component &#123; vm.$el = el if (!vm.$options.render) &#123; vm.$options.render = createEmptyVNode if (process.env.NODE_ENV !== &apos;production&apos;) &#123; /* istanbul ignore if */ if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== &apos;#&apos;) || vm.$options.el || el) &#123; warn( &apos;You are using the runtime-only build of Vue where the template &apos; + &apos;compiler is not available. Either pre-compile the templates into &apos; + &apos;render functions, or use the compiler-included build.&apos;, vm ) &#125; else &#123; warn( &apos;Failed to mount component: template or render function not defined.&apos;, vm ) &#125; &#125; &#125; callHook(vm, &apos;beforeMount&apos;) ... return vm &#125; 4.beforeMount之后，mounted之后官方图示当中给出这一阶段的描述是Create vm.$el and replace &quot;el&quot; with it, 我么继续看源码，看看vue到底是如何做到的。上面说到mountComponent这个函数，其实还没有结束，我们继续看剩下的代码，下面代码我省略了很多，只贴了比较重要的一段代码，这里调用了vm._render()。1 2 3 updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating) &#125; 这里调用了render.call(vm._renderProxy, vm.$createElement)，最终的vnode就是在这里生成的的，而这里的render函数，恰好也就是上个阶段中生成的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Vue.prototype._render = function (): VNode &#123; const vm: Component = this const &#123; render, _parentVnode &#125; = vm.$options ... // render self let vnode try &#123; vnode = render.call(vm._renderProxy, vm.$createElement) &#125; catch (e) &#123; ... &#125; ... return vnode &#125; 生成vnode之后，我们再返回到mountComponent，看看调用vm._render()的vm._update都做了什么。先判断的当前的生命状态，我们执行到这里_isMounted显然还是false，之后我们看到了这一句vm.$el = vm.__patch__(prevVnode, vnode)，这里将vnode生成了真实的dom节点，关于__patch__方法，里面的内容很多，之后会再去研究里面的源码。1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this if (vm._isMounted) &#123; callHook(vm, &apos;beforeUpdate&apos;) &#125; const prevEl = vm.$el const prevVnode = vm._vnode const prevActiveInstance = activeInstance activeInstance = vm vm._vnode = vnode // Vue.prototype.__patch__ is injected in entry points // based on the rendering backend used. if (!prevVnode) &#123; vm.$el = vm.__patch__( vm.$el, vnode, hydrating, false /* removeOnly */, vm.$options._parentElm, vm.$options._refElm ) vm.$options._parentElm = vm.$options._refElm = null &#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode) &#125; ... &#125; 虽然这一阶段的主要任务已经完成了，但是我们再一次回到mountComponent函数，看看update之后做了什么，这里new了一个watcher，这一句太重要了，这里我先看前两个参数，一个是当前的vm实例，一个是我们之前用的updateComponent函数，但是这里我们先不分析这个watcher的作用，我们在下一个阶段会提到。new了一个wathcer之后，我们看到mounted钩子函数执行，_isMounted也设置为了true，到此，我们这个阶段也结束了。在实际开发中，这个阶段DOM和vm中的各种属性已经都存在了，此时我们可以用mounted钩子函数做一些http请求之类的动作，完成页面的初始化。1 2 3 4 5 6 7 new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */) hydrating = false if (vm.$vnode == null) &#123; vm._isMounted = true callHook(vm, &apos;mounted&apos;) &#125; 5.mounted之后，beforeDestory之前我们写vue的时候经常会发现当我们改了某个data之后，不需要刷新页面，页面的上的内容会自动更新，也就是DOM自动重新渲染了，这个是怎么做到的呢？那就让我们继续看接下来的代码吧。还记得前面的watcher吗，这里我们将用到这个watcher，watcher的作用是什么呢？很简单，实现对vm中数据的监听，每当数据有任何改变的时候，我们都会调用watcher中的updateComponent方法，updateComponent的作用前面我们已经说过了，这里就不再介绍了。这里执行到_update方法的时候，之前同样遇到的vm._isMounted此时为true，那对应的钩子函数callHook(vm, &#39;beforeUpdate&#39;)也会执行。 关于watcher是如何实现的，其中有个核心的方法是javascript原生的Object.defineProperty，具体源码中怎么实现，之后我会写另一篇文章来详细介绍wathcer和dep的实现，以及nextTick是怎么工作的。 1 2 3 4 5 Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this if (vm._isMounted) &#123; callHook(vm, &apos;beforeUpdate&apos;) &#125; 我们在watcher.js中可以看到以下代码,update函数只有在数据发生更新的时候才会被触发，这里vue默认用的是异步DOM更新，所以我们看queueWatcher里面的内容。 这里要提醒的是vue里面并不是每次数据改变都会更新dom，这么做性能太差，所以会触发更新dom的操作都会缓存在一个队列中，等一个事件循环结束，统一更新dom，queueWatcher就在于此。1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * Subscriber interface. * Will be called when a dependency changes. */ update () &#123; /* istanbul ignore else */ if (this.lazy) &#123; this.dirty = true &#125; else if (this.sync) &#123; this.run() &#125; else &#123; queueWatcher(this) &#125; &#125; 在queueWatcher中,我们看到nextTick的执行，我们看一下官网，了解一下这个函数，nextTick在下次 DOM 更新循环结束之后执行延迟回调。可以知道此时watcher并不是立即更新dom，而是被推进了一个队列。1 2 3 4 5 6 7 8 9 10 11 export function queueWatcher (watcher: Watcher) &#123; const id = watcher.id if (has[id] == null) &#123; ... // queue the flush if (!waiting) &#123; waiting = true nextTick(flushSchedulerQueue) &#125; &#125; &#125; 继续看一下flushSchedulerQueue这个函数是什么，这段代码中有一段是给queue排序的，为了保证组件更新是从父组件到子组件等，代码就不贴了，我们主要看callUpdatedHooks(updatedQueue)，最终这一句中，updated钩子函数被调用，数据更新这一阶段基本完成。1 2 3 4 5 6 7 8 9 10 11 function flushSchedulerQueue () &#123; flushing = true let watcher, id ... callActivatedHooks(activatedQueue) callUpdatedHooks(updatedQueue) ... &#125; 5.beforeDestory之后，destoryed之前一般来说，vue不会主动去销毁一个组件，只有当我们调用$destroy()方法时，才会销毁一个组件，我们看一下$destroy()的源码，可以看到基本就是进行一些解绑watcher，将自己从父组件移除，解绑一些数据的工作，但是注意的是，vue只是把这些属性解绑，并不是直接删除这个组件，这点与react还是不同的。1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 Vue.prototype.$destroy = function () &#123; const vm: Component = this if (vm._isBeingDestroyed) &#123; return &#125; callHook(vm, &apos;beforeDestroy&apos;) vm._isBeingDestroyed = true // remove self from parent const parent = vm.$parent if (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) &#123; remove(parent.$children, vm) &#125; // teardown watchers if (vm._watcher) &#123; vm._watcher.teardown() &#125; let i = vm._watchers.length while (i--) &#123; vm._watchers[i].teardown() &#125; // remove reference from data ob // frozen object may not have observer. if (vm._data.__ob__) &#123; vm._data.__ob__.vmCount-- &#125; // call the last hook... vm._isDestroyed = true // invoke destroy hooks on current rendered tree vm.__patch__(vm._vnode, null) // fire destroyed hook callHook(vm, &apos;destroyed&apos;) // turn off all instance listeners. vm.$off() // remove __vue__ reference if (vm.$el) &#123; vm.$el.__vue__ = null &#125; // release circular reference (#6759) if (vm.$vnode) &#123; vm.$vnode.parent = null &#125; &#125; &#125; 4.总结结合vue源码来看，只是为了更理解vue的整个生命周期，当然，文章当中很多地方没有深入研究，比如vnode的diff，watcher等，因为这些内容实在庞大，完全可以另写一篇博客来单独研究，在这里主要是为了整理生命周期，所以就不往下深入了。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFC探索]]></title>
    <url>%2F2018%2F11%2F19%2Flionel1-BFC%2F</url>
    <content type="text"><![CDATA[一直都记得BFC就是“块级格式上下文”，记得这个名词但是对具体的说明不甚了解，今天找点材料仔细分析一下。首先要记住： 所谓的BFC就是css布局的一个概念，是一块区域，一个环境。 一、 常见定位方案在讲BFC之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案。 普通流(normal flow) 在普通流中，元素按照其在HTML中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直至当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在HTML文档中的位置决定。 浮动(float) 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。 绝对定位(absolute positioning) 在绝对定位布局中，元素会脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。 二、BFC概念Formatting context（格式化上下文）是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素如何定位，以及和其他元素的关系和相互作用，它属于上述定位方案的普通流。 那么BFC是什么呢？ BFC即Block Formatting Contexts（块级格式化上下文）。 具有BFC特性的元素可以看做是隔离了的独立容器，容器里面的元素不会再布局上影响到外面的元素，并且BFC具有普通容器所没有的一些特性 通俗一点来讲，可以把BFC理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 常见的FC有BFC、IFC（行级格式化上下文），还有GFC（网格布局格式化上下文）和FFC（自适应格式化上下文），这里就不再展开。 三、触发BFC只要元素满足下面任一条件即可触发BFC特性： body根元素 浮动元素： float除none以外的值 绝对定位元素： position(absolute、fixed) display为inline-block、table-cells、flex overflow除了visible以外的值（hidden、auto、scroll） 四、BFC布局规则： 内部的Box会在垂直方向，一个接一个的放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。 每个元素的margin box的左边，与包含块border box的左边相接触（对于从左往右的格式化，否则相反）。即时存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之如此。 计算BFC的高度时，浮动元素也参与计算。 五、BFC特性及应用1.同一个BFC下外边距会发生折叠2.BFC可以包含浮动的元素（清除浮动）3.BFC可以组织元素被浮动元素覆盖 参考：10分钟理解BFC原理]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>前端面试系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试系列(二)]]></title>
    <url>%2F2018%2F11%2F17%2Fmianshi2%2F</url>
    <content type="text"><![CDATA[前端面试系列(二)26个精选的JavaScript面试问题作者：Fundebug Q1: JavaScript中类型转换是怎样的？Q2:js中的作用域是怎样的？Q3: 请解释js中的相等判断Q4：请解释什么叫做回调函数并提供一个简单的例子Q5：”use strict”到底有何用处？Q6: 请解释null和undefinedQ7:请实现如下函数Q8:请解释js中的值和类型Q9:请解释事件冒泡以及如何阻止它？Q10：请解释js中的let关键字Q11：如何检查一个数字是否是正数。Q12：什么叫IIFEsQ13：如何比较js中的两个对象？Q14：请解释es5和es6的不同点Q15：请解释 undefined 和 not dufined的区别Q16：匿名函数和命名函数的区别？Q17：js中闭包是什么？请提供一个例子Q18：在js中如何创建私有变量Q19：请解释原型模式Q20：判断给定的字符串是否同态Q21：Transpiling代表了什么意思？Q22：this关键字如何工作？请提供一些例子Q23：如何为Array对象添加你自定义的函数，求数组平均数。Q24：js中提升(hoisting)是什么意思？Q25：0.1 + 0.2 === 0.3Q26：请描述一下揭示模式（Revealing Module Pattern）Q27：new干了什么 Q1: JavaScript中类型转换是怎样的？在js中，在两个不同类型之间的转换叫做coercion。在js中有两种形式：显示转换和隐式转换。 1 2 3 4 5 6 7 8 9 10 11 // 下面是一个显示转换的例子： var a = &quot;42&quot;; var b = Number(a); a; //&quot;42&quot; b; // 42 // 下面是一个隐式转换的例子： var a = &quot;42&quot;; var b = a * 1; a; // &quot;42&quot; b; // 42 Q2:js中的作用域是怎样的？在js中，每一个函数都有各自的作用域（scope）。作用域可以理解为是一个变量的集合以及相应的如何访问它的规则。只有在函数内部的变量才可以访问到该函数域的变量。在同一个作用域内部，变量名必须要唯一。作用域可以嵌套。在最内部的作用域中，可以访问任何外部的作用域中的变量。 Q3: 请解释js中的相等判断js中的相等判断有严格判断和带隐式转换的判断两种： 严格判断：比如===，比较的时候不会隐式转换类型； 抽象判断：比如==，比较的时候会隐式转换类型。 1 2 3 4 var a = &quot;42&quot;; var b = 42; a == b; // true a === b; // false 一些简单的规则： 如果两边都是布尔类型的值，使用===； 如果两边是0，””，[]，使用===； 所有其它类型，使用==是安全的。而且在很多情况下会简化代码、增加可读性。 Q4：请解释什么叫做回调函数并提供一个简单的例子回调函数是一个函数，他被作为参数传入另一个函数，当某些操作结束后，该函数被调用。下面是一个简单的例子，当数组被修改后，调用回调函数打印一行日志。 1 2 3 4 5 6 7 8 function modifyArray(arr, callback) &#123; arr.push(100); callback(); &#125; var arr = [1, 2, 3, 4, 5]; modifyArray(arr, function() &#123; console.log(&quot;array has been modified&quot;, arr) &#125;) Q5：”use strict”到底有何用处？use strict放在文件的顶部或函数的第一行来启动更加严格的检查，来避免失误引起的错误。比如，下面的代码会抛出错误： 1 2 3 4 function doSomething(val) &#123; &quot;use strict&quot;; x = val + 10; &#125; 因为x没有定义，如果使用了use strict，x是不会被当做全局的变量来看待。使用var x = val + 10即可修复。 Q6: 请解释null和undefinedjs和ts有两个最基本的类型null和undefined。它们的含义是不同的： null表示“没有对象”，即该处不应该有值，或尚未存在的对象。 undefined表示“缺少值”，就是此处应该有值，但是还没有定义。典型用法是：– 变量被声明了，但是没有赋值– 调用函数时，应该提供的参数没有提供– 对象没有赋值的属性– 函数没有返回值，默认返回undefined Q7:请实现如下函数1 2 3 var addSix = createBase(6); addSix(10); // return 16 addSix(21); // return 27 addSix是一个函数，也就是说createBase函数的返回是一个函数。 1 2 3 4 5 6 var createBase = function(x) &#123; return function(y)&#123; return x + y console.log(&apos;return &apos; + (x+y)) &#125; &#125; Q8:请解释js中的值和类型下面是js内置的可用类型： string number boolean null 和 undefined object symbol Q9:请解释事件冒泡以及如何阻止它？事件冒泡的概念是指：在最内层的元素上绑定的事件被触发后，会按照嵌套的层次由内向外逐步触发。因此，点击某个子节点可能会触发父节点的事件。一个阻止事件冒泡的办法就是使用event.stopPropagation(), 在IE&lt;9的浏览器上使用event.cancelBubble。 1 2 3 4 5 6 7 function stopPropagation(evt) &#123; if (typeof evt.stopPropagation === &quot;function&quot;) &#123; evt.stopPropagation(); &#125; else &#123; evt.cancelBubble = true; &#125; &#125; Q10：请解释js中的let关键字ES6允许你使用欧冠let关键字来声明快作用于的变量。 Q11：如何检查一个数字是否是正数。一个最简单的方法是判断除以1的余数是否为0. 1 2 3 function isInt(num) &#123; return num % 1 === 0; &#125; Q12：什么叫IIFEs立即执行函数，顾名思义，该表达式已被创建就立即执行。 1 2 3 (function IIFE() &#123; console.log(&apos;hello&apos;); &#125;)(); 该方法常用语避免污染全局的命名空间，IIFE中使用的变量外部无法访问。 Q13：如何比较js中的两个对象？两个非基本类型的值，比如对象(包括函数和数组)都是通过引用的形式来访问。如果直接通过==和===来判断，那么只会简单的判断其引用地址是否相同，而不是他们实际对应的值。如果数组和字符串做比较，那么数组会通过逗号拼接转换为字符串。通过等号判断的时候，两个相同的数组不会相等，但是和相同数据的字符串比较反而相等。 1 2 3 4 5 6 7 var a = [1, 2, 3]; var b = [1, 2, 3]; var c = &apos;1,2,3&apos;; a == c; // true b == c; // true a == b; // false 如果要深度比较，可以使用第三方库，比如deep-equal或者你自己实现一个比较算法。 Q14：请解释es5和es6的不同点 ES5：于2009年标准化，几乎所有的浏览器都完全支持。 ES6：于2015年标准化，目前各大浏览器只是部分支持。接下来介绍他们主要的区别： 箭头函数和字符换嵌入： 1 2 3 const greeting = (name) =&gt; &#123; return `hello $&#123;name&#125;`; &#125; 甚至： 1 const greetings = name =&gt; `hello $&#123;name&#125;`; 常量声明（const）：如同其他编程语言中的常量一样，但又有不同。这里的const代表了constant reference。也就是说，你可以修改其指向的对象的值。但是你不能修改其reference的值。 1 2 3 4 const NAMES = []; NAMES.push(&quot;Jim&quot;); console.log(NAMES.length === 1); // true NAMES = [&quot;Steve&quot;, &quot;John&quot;]; // error 块作用域变量：ES6中的新关键字let允许开发者将变量的作用域限定在块级别。不会像var一样变量提升。 参数默认值： 允许在函数定义的时候指定默认的值。 1 2 3 4 function multiply (a, b = 2)&#123; return a * b; &#125; multiply(5); // 10 类定义和继承ES6开始支持定义类（使用class关键字），构造函数（使用constructor关键字），和extend关键字来实现继承。 for-of操作for...of语句用来迭代访问一个对象的所有属性。 Spread操作符：用于对象合并 1 2 3 const obj1 = &#123;a:1, b:2&#125;; const obj2 = &#123;a:2, c:3&#125;; const obj3 = &#123;...obj1, ...obj2&#125; Promise: Promises提供了一个处理异步操作的方法。你可以用回调函数来实现，但是promise更加简洁和可读。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const isGreater = (a, b) =&gt; &#123; return new Promise((resolce, reject) =&gt; &#123; if(a&gt;b) &#123; resolve(true) &#125; else &#123; reject(false) &#125; &#125;) &#125; isGreater(1, 2) .then(result =&gt; &#123; console.log(&apos;greater&apos;) &#125;).catch(result =&gt; &#123; console.log(&apos;samller&apos;) &#125;) 模块的export和import。 1 2 const myModule = &#123;x:1, y: () =&gt; &#123;console.log(&apos;This is ES5&apos;)&#125;&#125; export default myModule; 1 import myModule from &apos;./myModule&apos;; Q15：请解释 undefined 和 not dufined的区别在js中，如果你尝试使用不存在的还未声明的变量，js会抛出错误 var name is not defined 。但是如果你使用 typeof 来查看其类型，则会返回 undefined 。我们先来澄清一下声明和定义的区别： var x 是一个声明，因为你并没有定义具体的值，你只是声明其存在性。如果我们访问了一个声明了但是未定义的变量，则会返回 undefined 。如果我们访问了一个未声明而且未定义的变量，则会返回 not defined 错误。 Q16：匿名函数和命名函数的区别？1 2 var foo = function()&#123;...&#125; var foo = function bar()&#123;...&#125; Q17：js中闭包是什么？请提供一个例子闭包是一个定义在其他函数里面的函数，它拥有对父函数里面变量的访问权。闭包拥有如下三个作用域的访问权： 自身的作用域 父作用域 全局作用域 Q18：在js中如何创建私有变量你可以通过函数中声明变量来创建私有变量。因为在函数中，外部无法直接访问，为了访问该变量，可以构造一个帮助函数来返回该值。1 2 3 4 5 6 7 8 9 10 function func()&#123; var priv = &quot;secret code&quot;; return function() &#123; return priv; &#125; &#125; console.log(priv); // thows error var getPriv = func(); console.log(getPriv()); // secret code Q19：请解释原型模式原型模式会创建一个新的对象，但是不会创建一个未初始化的对象，而是通过拷贝原型链上的值或被拷贝对象的值来完成初始化。传统的语言很少使用原型模式，但是js作为一个基于原型的语言，使用原型模式来创建新的对象。 Q20：判断给定的字符串是否同态首先介绍什么叫做同态：两个字符串，如果A字符串的每一个字符都可以在B字符串中找到唯一对应，并且顺序一一对应；如果存在这样的函数，那么A和B同态。 paper 和 title 同态 egg 和 sad 不同态 dgg 和 add 同态 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 isIsomorphic(&apos;egg&apos;, &apos;add&apos;); // true isIsomorphic(&apos;paper&apos;, &apos;title&apos;); // true isIsomorphic(&apos;kick&apos;, &apos;side); // false function isIsomorphic(fir, sec) &#123; if (fir.length !== sec.length) return false; var letterMap = &#123;&#125;; for(var i = 0; i &lt; fir.length; i++&gt;) &#123; var letterA = fir[i], letterB = sec[i]; if(letterMap[letterA] == undefined) &#123; letterMap[letterA] = letterB; &#125; else if (letterMap[letterA] !== letterB) &#123; return false; &#125; &#125; return true; &#125; Q21：Transpiling代表了什么意思？Transpiling 是 transforming + compiling 的合成词。对于一个新的语法，浏览器还不支持。最好的办法就是将其变换到旧的等价的代码，这个过程通常叫做 transpiling 。典型的，你可以在 build 的过程中加入 transpiler ，就如同 code linter 和 minifier 一样。 Q22：this关键字如何工作？请提供一些例子在js中，this总是指向函数的拥有者（也就是指向该函数的对象），或者拥有该函数的对象。1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function foo() &#123; console.log(this.bar); &#125; var bar = &quot;global&quot;; var obj1 = &#123; bar: &quot;obj1&quot;, foo: foo &#125;; var obj2 = &#123; bar: &apos;obj2&apos; &#125; foo(); // global obj1.foo(); // obj1 foo.call(obj2); // obj2 new foo(); // undefined Q23：如何为Array对象添加你自定义的函数，求数组平均数。1 2 3 var arr = [1, 2, 3, 4, 5]; var avg = arr.average(); // 求数组平均数 console.log(avg); js是一个基于原型的语言。也就是说对象之间通过原型链接，并集成其函数。为了给Array对象添加函数，我们可以修改其原型定义 Array prorotype 。1 2 3 4 Array.prototype.average = function() &#123; var sum = this.reduce(function(perv, cur) &#123;return prev + cur;&#125;); return sum / this.length; &#125; Q24：js中提升(hoisting)是什么意思？提升是指js的解释器将所有的变量和函数声明都提升到该作用域的顶部，有两种提升类型： 变量提升 函数提升在一个作用域中通过声明的变量和函数在整个作用域中都可以使用。 Q25：0.1 + 0.2 === 0.3返回false。因为浮点数在系统内的精确度问题，0.1 + 0.2的结果并不是0.3，而是0.30000000000000004。要避免这个问题的方法是指定返回结果的小数位数。 Q26：请描述一下揭示模式（Revealing Module Pattern）Module pattern的一个变种是Revealing Module Pattern。该设计模式的目的是做到很好的代码隔离，只是将需要对外公开的变量暴露出来。一个直接的实现如下所示：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var Exposer = (function() &#123; var privateVariable = 10; var privateMethod = function() &#123; console.log(&apos;Inside a private method!&apos;); privateVaribale++; &#125; var methodToExpose = function() &#123; console.log(&apos;This is a method I want to expose!&apos;); &#125; var otherMethodIWantToExpose = function() &#123; privateMethod(); &#125; return &#123; first: methodToExpose, second: otherMethodIWantToExpose &#125;; &#125;)(); Q27：new干了什么 新生成了一个对象 链接到原型 绑定this 返回新对象 1 2 3 4 5 6 7 8 9 10 11 12 function new() &#123; // 创建了一个空的对象 let obj = new Object() // 获得构造函数 let Con = [].shift.call(arguments) // 链接到原型 obj.__proto__ = Con.prototype // 绑定this，执行构造函数 let result = Con.apply(obj, arguments) // 确保new出来的是个对象 return typeof result === &apos;object&apos; ? result : obj &#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>前端面试系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试系列(一)]]></title>
    <url>%2F2018%2F11%2F17%2Fmianshi%2F</url>
    <content type="text"><![CDATA[前端面试系列(一) Q1:什么情况下会碰到跨域问题？有哪些解决方案 跨域问题是浏览器为了安全实施的同源策略导致的，同源策略限制了来自不同源的document、脚本，同源的意思就是两个URL的域名、协议、端口要完全相同。 script标签jsonp跨域、nginx反向代理、node.js中间件代理跨域、后端在头部信息设置安全域名、后端在服务器上设置cores。 Q2: 如何判断一个变量时对象还是数组？ 判断数组和对象分别都有好几种方法，其中用prototype.toString.call()兼容性最好。 1 2 3 4 5 6 7 8 9 function is ObjArr(value) &#123; if (Object.prototype.toString.call(value) === &quot;[Object Array]&quot;) &#123; console.log(&quot;value是数组&quot;); &#125; else if(Object.prototype.toString.call(value) === &quot;[Object Object]&quot;)&#123; // 这个方法兼容性好一点 console.log(&quot;value是对象&quot;); &#125; else &#123; console.log(&quot;value不是对象也不是数组&quot;); &#125; &#125; ps:千万不能用typeof来判断对象和数组，因为这两种类型都会返回“object”。 Q3:定时器的执行顺序或机制。 因为js是单线程的，浏览器遇到setTimeout或者setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的待执行事件队列里面，等到浏览器执行完当前代码之后会看一下事件队列里面有没有任务，有的话才会执行定时器的代码。 Q4: html中title属性和alt属性的区别： 1 2 3 4 5 1. &lt;img src=&quot;#&quot; alt=&quot;alt信息&quot; /&gt; // 1. 当图片不输出信息的时候，会显示alt信息，鼠标放上去没有信息，当图片正常读取，不会出现alt信息 2. &lt;img src=&quot;#&quot; alt=&quot;alt信息&quot; title=&quot;title信息&quot; /&gt; // 2. 当图片不输出信息的时候，会显示alt信息，鼠标放上去会出现title信息 // 当图片正常输出的时候，不会出现alt信息，鼠标放上去会出现title信息。 title属性可以用在除了base,basefont,head,html,meta,param,script和title之外的所有标签title属性的功能是提示。额外的说明信息和非本质的信息请使用title属性。title属性值可以比alt属性值设置的更长title属性有一个很好的用途，即为连接添加描述性文字，特别是当连接本身并不是十分清楚的表达了链接的目的。 Q5: ES5的继承和ES6的继承有什么区别？ ES5的继承是通过prototype或构造函数机制来实现。ES5的继承实质上试先创建子类的实例对象，然后再将父类的方法添加到this上(Parent.apply(this))。ES6的继承机制完全不同，实质上是先创建父类的实例对象this(所以必须先调用父类的super()方法)，然后再用子类的构造函数修改this。具体的：ES6通过class关键字定义类，里面有构造方法，类之间通过extends关键字实现继承。子类必须在constructor方法中调用super方法，否则新建实例报错。因为子类没有自己的this对象，而是继承了父类的this对象，然后对其进行加工。如果不调用super方法，子类得不到this对象。ps：super关键字指代父类的实例，即父亲的this对象。在子类构造函数中，调用super后，才可以使用this关键字，否则报错。 Q6：CSS3有哪些新增的属性？ 这里可以分为边框、背景，渐变，阴影，2D转换，3D转换等。 Q7: 你知道哪些http状态码？ 1xx: 1开头的是信息状态码2xx: 2开头的是请求成功3xx: 3开头的是重定向4xx: 4开头的是客户端错误 400：请求无效产生原因： 前端提交数据的字段名和字段类型与后台的实体没有保持一致 前端提交到后台的数据应该是json字符串类型，但是前端没有将对象JSON.stringify转化成字符串。 401: 当前请求需要用户验证 403：服务器已经得到请求，但是拒绝执行。 5xx: 5开头的是服务器错误 Q8: 如何对一个数组去重？ Set解构去重。这是ES6提供了新的数据结构Set。它类似于数组，但是会自动去重。 1 2 let unique = [... new Set(array)]; // Set内部使用===来判断是否相等，&apos;1&apos;和1都会保存，NaN和NaN只会保存一个。 遍历，将值添加到新数组，用indexOf()判断值是否存在，已存在就不添加，达到去重效果 1 2 3 4 5 6 7 8 9 10 11 12 let a = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,1,NaN,NaN,undefined,undefined,null,null,&apos;a&apos;,&apos;b&apos;,&apos;b&apos;]; let unique = arr =&gt; &#123; let newA = []; arr.forEach(key =&gt; &#123; if (newA.indexOf(key) &lt; 0)&#123; newA.push(key); &#125; &#125;); return newA; &#125; console.log(unique(a));//[&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,1,NaN,NaN,undefined,null,&apos;a&apos;,&apos;b&apos;] // ps:这个方法不能分辨NaN，会出现两个NaN。是有问题的，下面的好一点。 遍历，将数组的值添加到一个对象的属性名里，并给属性赋值，对象不能添加相同属性名，以这个为依据可以实现数组去重，然后用Object.key(对象)返回这个对象可枚举属性组成的数组，这个数组就是去重后的数组。 1 2 3 4 5 6 7 8 9 let a = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,1,NaN,NaN,undefined,undefined,null,null,&apos;a&apos;,&apos;b&apos;,&apos;b&apos;]; const unique = arr =&gt; &#123; var obj = &#123;&#125;; arr.forEach(value =&gt; &#123; obj[value] = 0; // 这步添加一个属性，并赋值，如果不赋值，属性添加不上去。 &#125;) return Object.keys(obj); &#125; console.log(unique(a));//[&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,1,NaN,undefined,null,&apos;a&apos;,&apos;b&apos;] 注意：这个方法会将number，NaN，undefined，null变为字符串形式，因为对象的属性名就是一个字符串，根据需求来吧，想象还是Set去重最简单也最有效。 Q9: 垂直居中有哪些方法？ 单行文本的话可以使用height和line-height设置同一高度。 position+margin(定高)：设置父元素：position:relative;，子元素height: 100px;position:absolute;top:50%;margin:-50px 0 0 0; position+transform(不定高): 设置父元素position:relatice，子元素：position:absolute;top:50%;transform: translate(0,-50%); 百搭flex布局(ie10+)(不定高)：设置父元素display:flex;align-items:center Q10:翻转一个字符串 思路是先将字符串转成一个数组，然后用数组的reverse()+join()方法。1 2 let str = &quot;hello word&quot;; let b = [...str].reverse().join(&quot;&quot;);// drow olleh Q11: 了解ES6的let和const变量声明吗？跟ES5的var有哪些区别？ let 在同一个作用域里面： var可以重复声明变量，let不能重复声明同一变量。ES5是函数作用域，即一个函数里面才是一个作用域。ES6是块级作用域，花括号里面就是一个作用域。 var有变量提升，可以在变量声明之前使用，let不存在变量提升，在变量之前使用会报错。 let有暂时性死区，即父作用域中有var定义，在块作用域里又定义了let，那在块let之前使用，就是死区。 const const的很多特性跟let的特性一样，都有：不可重复声明，不存在变量提升，有暂时性死区，都是块级作用域。 和let不一样的地方：const必须在声明的时候赋值，不然会报错。const声明的常量不能更改。值引用是完全不能更改，引用类型，const只能保证指针是固定的。 Q12: 继承函数对象的实例方法、原型的继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function father(name) &#123; // 父函数 this.name = name||&apos;lionel&apos;; this.code = function() &#123; // 父函数的实例方法 console.log(this.name + &apos;coding&apos;); &#125; &#125;; father.prototype.add = function(food) &#123; // 父函数的原型方法 console.log(this.name + &apos;eat&apos; + food); &#125; function son(name) &#123; // 子函数 father.call(this); // 将this绑定到子类，绑定父类的实例方法code(原型方法还未绑定) this.name = name || &apos;lionel1&apos;; &#125; son.prototype = new father(); // 把父函数的原型方法绑定到子类，实现继承 var sonVar = new son(&apos;faker&apos;); // 这里也可以传参name son.prototype.constructor = son; // 修复构造函数的指向 console.log(sonVar.code()); console.log(sonVar.add()); // 可以调用父类的方法了 Q13: 通过reduce函数来实现简单的数组求和，示例数组[3, 4, 8, 0, 9] 三种方法，一种是常见的遍历方法，另一种是eval()方法，还有一种是reduce()函数1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 第一种常规遍历 let reduce = (arr) =&gt; &#123; let num = 0; for (let [index, value] of arr.entries())&#123; num += value; &#125; return num; &#125; // 第二种 let reduce = (arr) =&gt; eval(arr.join(&quot;+&quot;)); // 第三种 let result = [3, 4, 8, 0, 9].reduce((total, value) =&gt; &#123; return total + value &#125;) Q14: call()和apply()有什么区别？ call()和apply()第一个参数将用作函数内this的值，用于改变函数的this执行。区别在于，call()方法接收逗号分隔的参数作为后面的参数，apply()接收一个参数数组作为后面的参数，可以从apply联想到array。 Q15: position有哪些值？有什么作用？ static：默认值，不脱离文档流，top，right，bottom，left等属性不生效。 relative：不脱离文档流，依据自身位置进行偏离，当子元素设置absolute，将依据它进行偏离。 absolute：脱离文档流，依据top，right，bottom，left等属性在正常文档流中偏移位置。 fixed：通过浏览器窗口进行定位，出现滚动条的时候，不会随之滚动。 Q16: 如何实现一个闭包？闭包的作用有哪些？ 在一个函数里面嵌套另一个函数，被嵌套的那个函数的作用域是一个闭包。 作用： 创建私有变量，减少全局变量，防止变量名污染。可以操作外部作用域的变量，变量不会被浏览器回收，保存变量的值。 Q17: 请从2018-11-16T15:13Europe/Paris提取出结果[&#39;2018&#39;,&#39;11&#39;,&#39;16&#39;,&#39;15&#39;,&#39;13&#39;] 写一个只获取数字的正则表达式就行了。1 2 3 4 5 let str = &apos;2018-11-16T15:13Europe/Paris&apos;; let arr = str.match( /\d&#123;1,&#125;/g ); // \d 查找数字 // &#123;1,&#125;表示至少重复几次 // /g表示全局搜索 Q18:请描述一下promise的使用场景，它所解决的问题以及现在对于异步操作的解决方案。 promise的使用场景：ajax请求、回调函数、复杂操作判断。promise是ES6为了解决异步编程所诞生。异步操作的解决方案：promise、generator、ES7的async。 Q19: Vuex的工作流程，以及它的作用，使用场景。 Vuex工作流程： 在vue组件里面，通过dispatch来触发actions，提交修改数据的操作。 然后在通过actions的commit来触发mutations，修改数据。 mutations接收到commit的请求，就会自动通过Mutate来修改state里面的数据。 最后store触发每一个调用它的组件的更新 Vuex的作用：项目数据状态的集中管理，复杂组件（如兄弟组件、远方亲戚组件）的数据通信问题。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>前端面试系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2018%2F11%2F17%2FHello-Hexo%2F</url>
    <content type="text"><![CDATA[本地hexo server || hexo s上传hexo clean &amp;&amp; hexo g &amp;&amp; hexo d Hexo-admin插件允许我们直接在本地页面上修改文章内容。npm i hexo-admin --save本地修改 http://localhost:4000/admin 新建页面 hexo new &quot;pageName&quot;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1 $ hexo new "My New Post" More info: Writing Run server1 $ hexo server More info: Server Generate static files1 $ hexo generate More info: Generating Deploy to remote sites1 $ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
