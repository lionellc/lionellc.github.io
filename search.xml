<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端面试系列(一)]]></title>
    <url>%2F2018%2F11%2F17%2Fmianshi%2F</url>
    <content type="text"><![CDATA[Q1:什么情况下会碰到跨域问题？有哪些解决方案 跨域问题是浏览器为了安全实施的同源策略导致的，同源策略限制了来自不同源的document、脚本，同源的意思就是两个URL的域名、协议、端口要完全相同。 script标签jsonp跨域、nginx反向代理、node.js中间件代理跨域、后端在头部信息设置安全域名、后端在服务器上设置cores。 Q2: 如何判断一个变量时对象还是数组？ 判断数组和对象分别都有好几种方法，其中用prototype.toString.call()兼容性最好。 123456789function is ObjArr(value) &#123; if (Object.prototype.toString.call(value) === &quot;[Object Array]&quot;) &#123; console.log(&quot;value是数组&quot;); &#125; else if(Object.prototype.toString.call(value) === &quot;[Object Object]&quot;)&#123; // 这个方法兼容性好一点 console.log(&quot;value是对象&quot;); &#125; else &#123; console.log(&quot;value不是对象也不是数组&quot;); &#125;&#125; ps:千万不能用typeof来判断对象和数组，因为这两种类型都会返回“object”。 Q3:定时器的执行顺序或机制。 因为js是单线程的，浏览器遇到setTimeout或者setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的待执行事件队列里面，等到浏览器执行完当前代码之后会看一下事件队列里面有没有任务，有的话才会执行定时器的代码。 Q4: html中title属性和alt属性的区别： 123451. &lt;img src=&quot;#&quot; alt=&quot;alt信息&quot; /&gt;// 1. 当图片不输出信息的时候，会显示alt信息，鼠标放上去没有信息，当图片正常读取，不会出现alt信息2. &lt;img src=&quot;#&quot; alt=&quot;alt信息&quot; title=&quot;title信息&quot; /&gt;// 2. 当图片不输出信息的时候，会显示alt信息，鼠标放上去会出现title信息// 当图片正常输出的时候，不会出现alt信息，鼠标放上去会出现title信息。 title属性可以用在除了base,basefont,head,html,meta,param,script和title之外的所有标签title属性的功能是提示。额外的说明信息和非本质的信息请使用title属性。title属性值可以比alt属性值设置的更长title属性有一个很好的用途，即为连接添加描述性文字，特别是当连接本身并不是十分清楚的表达了链接的目的。 Q5: ES5的继承和ES6的继承有什么区别？ ES5的继承是通过prototype或构造函数机制来实现。ES5的继承实质上试先创建子类的实例对象，然后再将父类的方法添加到this上(Parent.apply(this))。ES6的继承机制完全不同，实质上是先创建父类的实例对象this(所以必须先调用父类的super()方法)，然后再用子类的构造函数修改this。具体的：ES6通过class关键字定义类，里面有构造方法，类之间通过extends关键字实现继承。子类必须在constructor方法中调用super方法，否则新建实例报错。因为子类没有自己的this对象，而是继承了父类的this对象，然后对其进行加工。如果不调用super方法，子类得不到this对象。ps：super关键字指代父类的实例，即父亲的this对象。在子类构造函数中，调用super后，才可以使用this关键字，否则报错。 Q6：CSS3有哪些新增的属性？ 这里可以分为边框、背景，渐变，阴影，2D转换，3D转换等。 Q7: 你知道哪些http状态码？ 1xx: 1开头的是信息状态码2xx: 2开头的是请求成功3xx: 3开头的是重定向4xx: 4开头的是客户端错误 400：请求无效产生原因： 前端提交数据的字段名和字段类型与后台的实体没有保持一致 前端提交到后台的数据应该是json字符串类型，但是前端没有将对象JSON.stringify转化成字符串。 401: 当前请求需要用户验证 403：服务器已经得到请求，但是拒绝执行。 5xx: 5开头的是服务器错误 Q8: 如何对一个数组去重？ Set解构去重。这是ES6提供了新的数据结构Set。它类似于数组，但是会自动去重。 12let unique = [... new Set(array)];// Set内部使用===来判断是否相等，&apos;1&apos;和1都会保存，NaN和NaN只会保存一个。 遍历，将值添加到新数组，用indexOf()判断值是否存在，已存在就不添加，达到去重效果 123456789101112let a = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,1,NaN,NaN,undefined,undefined,null,null,&apos;a&apos;,&apos;b&apos;,&apos;b&apos;];let unique = arr =&gt; &#123; let newA = []; arr.forEach(key =&gt; &#123; if (newA.indexOf(key) &lt; 0)&#123; newA.push(key); &#125; &#125;); return newA;&#125;console.log(unique(a));//[&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,1,NaN,NaN,undefined,null,&apos;a&apos;,&apos;b&apos;]// ps:这个方法不能分辨NaN，会出现两个NaN。是有问题的，下面的好一点。 遍历，将数组的值添加到一个对象的属性名里，并给属性赋值，对象不能添加相同属性名，以这个为依据可以实现数组去重，然后用Object.key(对象)返回这个对象可枚举属性组成的数组，这个数组就是去重后的数组。 123456789let a = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,1,NaN,NaN,undefined,undefined,null,null,&apos;a&apos;,&apos;b&apos;,&apos;b&apos;];const unique = arr =&gt; &#123; var obj = &#123;&#125;; arr.forEach(value =&gt; &#123; obj[value] = 0; // 这步添加一个属性，并赋值，如果不赋值，属性添加不上去。 &#125;) return Object.keys(obj);&#125; console.log(unique(a));//[&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,1,NaN,undefined,null,&apos;a&apos;,&apos;b&apos;] 注意：这个方法会将number，NaN，undefined，null变为字符串形式，因为对象的属性名就是一个字符串，根据需求来吧，想象还是Set去重最简单也最有效。 Q9: 垂直居中有哪些方法？ 单行文本的话可以使用height和line-height设置同一高度。 position+margin(定高)：设置父元素：position:relative;，子元素height: 100px;position:absolute;top:50%;margin:-50px 0 0 0; position+transform(不定高): 设置父元素position:relatice，子元素：position:absolute;top:50%;transform: translate(0,-50%); 百搭flex布局(ie10+)(不定高)：设置父元素display:flex;align-items:center Q10:翻转一个字符串 思路是先将字符串转成一个数组，然后用数组的reverse()+join()方法。12let str = &quot;hello word&quot;;let b = [...str].reverse().join(&quot;&quot;);// drow olleh Q11: 了解ES6的let和const变量声明吗？跟ES5的var有哪些区别？ let 在同一个作用域里面： var可以重复声明变量，let不能重复声明同一变量。ES5是函数作用域，即一个函数里面才是一个作用域。ES6是块级作用域，花括号里面就是一个作用域。 var有变量提升，可以在变量声明之前使用，let不存在变量提升，在变量之前使用会报错。 let有暂时性死区，即父作用域中有var定义，在块作用域里又定义了let，那在块let之前使用，就是死区。 const const的很多特性跟let的特性一样，都有：不可重复声明，不存在变量提升，有暂时性死区，都是块级作用域。 和let不一样的地方：const必须在声明的时候赋值，不然会报错。const声明的常量不能更改。值引用是完全不能更改，引用类型，const只能保证指针是固定的。 Q12: 继承函数对象的实例方法、原型的继承 123456789101112131415161718function father(name) &#123; // 父函数 this.name = name||&apos;lionel&apos;; this.code = function() &#123; // 父函数的实例方法 console.log(this.name + &apos;coding&apos;); &#125;&#125;;father.prototype.add = function(food) &#123; // 父函数的原型方法 console.log(this.name + &apos;eat&apos; + food);&#125;function son(name) &#123; // 子函数 father.call(this); // 将this绑定到子类，绑定父类的实例方法code(原型方法还未绑定) this.name = name || &apos;lionel1&apos;;&#125;son.prototype = new father(); // 把父函数的原型方法绑定到子类，实现继承var sonVar = new son(&apos;faker&apos;); // 这里也可以传参nameson.prototype.constructor = son; // 修复构造函数的指向console.log(sonVar.code());console.log(sonVar.add()); // 可以调用父类的方法了 Q13: 通过reduce函数来实现简单的数组求和，示例数组[3, 4, 8, 0, 9] 三种方法，一种是常见的遍历方法，另一种是eval()方法，还有一种是reduce()函数1234567891011121314// 第一种常规遍历let reduce = (arr) =&gt; &#123; let num = 0; for (let [index, value] of arr.entries())&#123; num += value; &#125; return num;&#125;// 第二种let reduce = (arr) =&gt; eval(arr.join(&quot;+&quot;));// 第三种let result = [3, 4, 8, 0, 9].reduce((total, value) =&gt; &#123; return total + value&#125;) Q14: call()和apply()有什么区别？ call()和apply()第一个参数将用作函数内this的值，用于改变函数的this执行。区别在于，call()方法接收逗号分隔的参数作为后面的参数，apply()接收一个参数数组作为后面的参数，可以从apply联想到array。 Q15: position有哪些值？有什么作用？ static：默认值，不脱离文档流，top，right，bottom，left等属性不生效。 relative：不脱离文档流，依据自身位置进行偏离，当子元素设置absolute，将依据它进行偏离。 absolute：脱离文档流，依据top，right，bottom，left等属性在正常文档流中偏移位置。 fixed：通过浏览器窗口进行定位，出现滚动条的时候，不会随之滚动。 Q16: 如何实现一个闭包？闭包的作用有哪些？ 在一个函数里面嵌套另一个函数，被嵌套的那个函数的作用域是一个闭包。 作用： 创建私有变量，减少全局变量，防止变量名污染。可以操作外部作用域的变量，变量不会被浏览器回收，保存变量的值。 Q17: 请从2018-11-16T15:13Europe/Paris提取出结果[&#39;2018&#39;,&#39;11&#39;,&#39;16&#39;,&#39;15&#39;,&#39;13&#39;] 写一个只获取数字的正则表达式就行了。12345let str = &apos;2018-11-16T15:13Europe/Paris&apos;;let arr = str.match( /\d&#123;1,&#125;/g );// \d 查找数字// &#123;1,&#125;表示至少重复几次// /g表示全局搜索 Q18:请描述一下promise的使用场景，它所解决的问题以及现在对于异步操作的解决方案。 promise的使用场景：ajax请求、回调函数、复杂操作判断。promise是ES6为了解决异步编程所诞生。异步操作的解决方案：promise、generator、ES7的async。 Q19: Vuex的工作流程，以及它的作用，使用场景。 Vuex工作流程： 在vue组件里面，通过dispatch来触发actions，提交修改数据的操作。 然后在通过actions的commit来触发mutations，修改数据。 mutations接收到commit的请求，就会自动通过Mutate来修改state里面的数据。 最后store触发每一个调用它的组件的更新 Vuex的作用：项目数据状态的集中管理，复杂组件（如兄弟组件、远方亲戚组件）的数据通信问题。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>前端面试系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2018%2F11%2F17%2FHello-Hexo%2F</url>
    <content type="text"><![CDATA[本地hexo server || hexo s上传hexo clean &amp;&amp; hexo g &amp;&amp; hexo d Hexo-admin插件允许我们直接在本地页面上修改文章内容。npm i hexo-admin --save本地修改 http://localhost:4000/admin 新建页面 hexo new &quot;pageName&quot;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
