<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BFC探索]]></title>
    <url>%2F2018%2F11%2F19%2Flionel1-BFC%2F</url>
    <content type="text"><![CDATA[一直都记得BFC就是“块级格式上下文”，记得这个名词但是对具体的说明不甚了解，今天找点材料仔细分析一下。首先要记住： 所谓的BFC就是css布局的一个概念，是一块区域，一个环境。 一、 常见定位方案在讲BFC之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案。 普通流(normal flow) 在普通流中，元素按照其在HTML中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直至当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在HTML文档中的位置决定。 浮动(float) 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。 绝对定位(absolute positioning) 在绝对定位布局中，元素会脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。 二、BFC概念Formatting context（格式化上下文）是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素如何定位，以及和其他元素的关系和相互作用，它属于上述定位方案的普通流。 那么BFC是什么呢？ BFC即Block Formatting Contexts（块级格式化上下文）。 具有BFC特性的元素可以看做是隔离了的独立容器，容器里面的元素不会再布局上影响到外面的元素，并且BFC具有普通容器所没有的一些特性 通俗一点来讲，可以把BFC理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 常见的FC有BFC、IFC（行级格式化上下文），还有GFC（网格布局格式化上下文）和FFC（自适应格式化上下文），这里就不再展开。 三、触发BFC只要元素满足下面任一条件即可触发BFC特性： body根元素 浮动元素： float除none以外的值 绝对定位元素： position(absolute、fixed) display为inline-block、table-cells、flex overflow除了visible以外的值（hidden、auto、scroll） 四、BFC布局规则： 内部的Box会在垂直方向，一个接一个的放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。 每个元素的margin box的左边，与包含块border box的左边相接触（对于从左往右的格式化，否则相反）。即时存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之如此。 计算BFC的高度时，浮动元素也参与计算。 五、BFC特性及应用1.同一个BFC下外边距会发生折叠2.BFC可以包含浮动的元素（清除浮动）3.BFC可以组织元素被浮动元素覆盖 参考：10分钟理解BFC原理]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>前端面试系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试系列(二)]]></title>
    <url>%2F2018%2F11%2F17%2Fmianshi2%2F</url>
    <content type="text"><![CDATA[前端面试系列(二)26个精选的JavaScript面试问题作者：Fundebug Q1: JavaScript中类型转换是怎样的？Q2:js中的作用域是怎样的？Q3: 请解释js中的相等判断Q4：请解释什么叫做回调函数并提供一个简单的例子Q5：”use strict”到底有何用处？Q6: 请解释null和undefinedQ7:请实现如下函数Q8:请解释js中的值和类型Q9:请解释事件冒泡以及如何阻止它？Q10：请解释js中的let关键字Q11：如何检查一个数字是否是正数。Q12：什么叫IIFEsQ13：如何比较js中的两个对象？Q14：请解释es5和es6的不同点Q15：请解释 undefined 和 not dufined的区别Q16：匿名函数和命名函数的区别？Q17：js中闭包是什么？请提供一个例子Q18：在js中如何创建私有变量Q19：请解释原型模式Q20：判断给定的字符串是否同态Q21：Transpiling代表了什么意思？Q22：this关键字如何工作？请提供一些例子Q23：如何为Array对象添加你自定义的函数，求数组平均数。Q24：js中提升(hoisting)是什么意思？Q25：0.1 + 0.2 === 0.3Q26：请描述一下揭示模式（Revealing Module Pattern）Q27：new干了什么 Q1: JavaScript中类型转换是怎样的？在js中，在两个不同类型之间的转换叫做coercion。在js中有两种形式：显示转换和隐式转换。 1 2 3 4 5 6 7 8 9 10 11 // 下面是一个显示转换的例子： var a = &quot;42&quot;; var b = Number(a); a; //&quot;42&quot; b; // 42 // 下面是一个隐式转换的例子： var a = &quot;42&quot;; var b = a * 1; a; // &quot;42&quot; b; // 42 Q2:js中的作用域是怎样的？在js中，每一个函数都有各自的作用域（scope）。作用域可以理解为是一个变量的集合以及相应的如何访问它的规则。只有在函数内部的变量才可以访问到该函数域的变量。在同一个作用域内部，变量名必须要唯一。作用域可以嵌套。在最内部的作用域中，可以访问任何外部的作用域中的变量。 Q3: 请解释js中的相等判断js中的相等判断有严格判断和带隐式转换的判断两种： 严格判断：比如===，比较的时候不会隐式转换类型； 抽象判断：比如==，比较的时候会隐式转换类型。 1 2 3 4 var a = &quot;42&quot;; var b = 42; a == b; // true a === b; // false 一些简单的规则： 如果两边都是布尔类型的值，使用===； 如果两边是0，””，[]，使用===； 所有其它类型，使用==是安全的。而且在很多情况下会简化代码、增加可读性。 Q4：请解释什么叫做回调函数并提供一个简单的例子回调函数是一个函数，他被作为参数传入另一个函数，当某些操作结束后，该函数被调用。下面是一个简单的例子，当数组被修改后，调用回调函数打印一行日志。 1 2 3 4 5 6 7 8 function modifyArray(arr, callback) &#123; arr.push(100); callback(); &#125; var arr = [1, 2, 3, 4, 5]; modifyArray(arr, function() &#123; console.log(&quot;array has been modified&quot;, arr) &#125;) Q5：”use strict”到底有何用处？use strict放在文件的顶部或函数的第一行来启动更加严格的检查，来避免失误引起的错误。比如，下面的代码会抛出错误： 1 2 3 4 function doSomething(val) &#123; &quot;use strict&quot;; x = val + 10; &#125; 因为x没有定义，如果使用了use strict，x是不会被当做全局的变量来看待。使用var x = val + 10即可修复。 Q6: 请解释null和undefinedjs和ts有两个最基本的类型null和undefined。它们的含义是不同的： null表示“没有对象”，即该处不应该有值，或尚未存在的对象。 undefined表示“缺少值”，就是此处应该有值，但是还没有定义。典型用法是：– 变量被声明了，但是没有赋值– 调用函数时，应该提供的参数没有提供– 对象没有赋值的属性– 函数没有返回值，默认返回undefined Q7:请实现如下函数1 2 3 var addSix = createBase(6); addSix(10); // return 16 addSix(21); // return 27 addSix是一个函数，也就是说createBase函数的返回是一个函数。 1 2 3 4 5 6 var createBase = function(x) &#123; return function(y)&#123; return x + y console.log(&apos;return &apos; + (x+y)) &#125; &#125; Q8:请解释js中的值和类型下面是js内置的可用类型： string number boolean null 和 undefined object symbol Q9:请解释事件冒泡以及如何阻止它？事件冒泡的概念是指：在最内层的元素上绑定的事件被触发后，会按照嵌套的层次由内向外逐步触发。因此，点击某个子节点可能会触发父节点的事件。一个阻止事件冒泡的办法就是使用event.stopPropagation(), 在IE&lt;9的浏览器上使用event.cancelBubble。 1 2 3 4 5 6 7 function stopPropagation(evt) &#123; if (typeof evt.stopPropagation === &quot;function&quot;) &#123; evt.stopPropagation(); &#125; else &#123; evt.cancelBubble = true; &#125; &#125; Q10：请解释js中的let关键字ES6允许你使用欧冠let关键字来声明快作用于的变量。 Q11：如何检查一个数字是否是正数。一个最简单的方法是判断除以1的余数是否为0. 1 2 3 function isInt(num) &#123; return num % 1 === 0; &#125; Q12：什么叫IIFEs立即执行函数，顾名思义，该表达式已被创建就立即执行。 1 2 3 (function IIFE() &#123; console.log(&apos;hello&apos;); &#125;)(); 该方法常用语避免污染全局的命名空间，IIFE中使用的变量外部无法访问。 Q13：如何比较js中的两个对象？两个非基本类型的值，比如对象(包括函数和数组)都是通过引用的形式来访问。如果直接通过==和===来判断，那么只会简单的判断其引用地址是否相同，而不是他们实际对应的值。如果数组和字符串做比较，那么数组会通过逗号拼接转换为字符串。通过等号判断的时候，两个相同的数组不会相等，但是和相同数据的字符串比较反而相等。 1 2 3 4 5 6 7 var a = [1, 2, 3]; var b = [1, 2, 3]; var c = &apos;1,2,3&apos;; a == c; // true b == c; // true a == b; // false 如果要深度比较，可以使用第三方库，比如deep-equal或者你自己实现一个比较算法。 Q14：请解释es5和es6的不同点 ES5：于2009年标准化，几乎所有的浏览器都完全支持。 ES6：于2015年标准化，目前各大浏览器只是部分支持。接下来介绍他们主要的区别： 箭头函数和字符换嵌入： 1 2 3 const greeting = (name) =&gt; &#123; return `hello $&#123;name&#125;`; &#125; 甚至： 1 const greetings = name =&gt; `hello $&#123;name&#125;`; 常量声明（const）：如同其他编程语言中的常量一样，但又有不同。这里的const代表了constant reference。也就是说，你可以修改其指向的对象的值。但是你不能修改其reference的值。 1 2 3 4 const NAMES = []; NAMES.push(&quot;Jim&quot;); console.log(NAMES.length === 1); // true NAMES = [&quot;Steve&quot;, &quot;John&quot;]; // error 块作用域变量：ES6中的新关键字let允许开发者将变量的作用域限定在块级别。不会像var一样变量提升。 参数默认值： 允许在函数定义的时候指定默认的值。 1 2 3 4 function multiply (a, b = 2)&#123; return a * b; &#125; multiply(5); // 10 类定义和继承ES6开始支持定义类（使用class关键字），构造函数（使用constructor关键字），和extend关键字来实现继承。 for-of操作for...of语句用来迭代访问一个对象的所有属性。 Spread操作符：用于对象合并 1 2 3 const obj1 = &#123;a:1, b:2&#125;; const obj2 = &#123;a:2, c:3&#125;; const obj3 = &#123;...obj1, ...obj2&#125; Promise: Promises提供了一个处理异步操作的方法。你可以用回调函数来实现，但是promise更加简洁和可读。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const isGreater = (a, b) =&gt; &#123; return new Promise((resolce, reject) =&gt; &#123; if(a&gt;b) &#123; resolve(true) &#125; else &#123; reject(false) &#125; &#125;) &#125; isGreater(1, 2) .then(result =&gt; &#123; console.log(&apos;greater&apos;) &#125;).catch(result =&gt; &#123; console.log(&apos;samller&apos;) &#125;) 模块的export和import。 1 2 const myModule = &#123;x:1, y: () =&gt; &#123;console.log(&apos;This is ES5&apos;)&#125;&#125; export default myModule; 1 import myModule from &apos;./myModule&apos;; Q15：请解释 undefined 和 not dufined的区别在js中，如果你尝试使用不存在的还未声明的变量，js会抛出错误 var name is not defined 。但是如果你使用 typeof 来查看其类型，则会返回 undefined 。我们先来澄清一下声明和定义的区别： var x 是一个声明，因为你并没有定义具体的值，你只是声明其存在性。如果我们访问了一个声明了但是未定义的变量，则会返回 undefined 。如果我们访问了一个未声明而且未定义的变量，则会返回 not defined 错误。 Q16：匿名函数和命名函数的区别？1 2 var foo = function()&#123;...&#125; var foo = function bar()&#123;...&#125; Q17：js中闭包是什么？请提供一个例子闭包是一个定义在其他函数里面的函数，它拥有对父函数里面变量的访问权。闭包拥有如下三个作用域的访问权： 自身的作用域 父作用域 全局作用域 Q18：在js中如何创建私有变量你可以通过函数中声明变量来创建私有变量。因为在函数中，外部无法直接访问，为了访问该变量，可以构造一个帮助函数来返回该值。1 2 3 4 5 6 7 8 9 10 function func()&#123; var priv = &quot;secret code&quot;; return function() &#123; return priv; &#125; &#125; console.log(priv); // thows error var getPriv = func(); console.log(getPriv()); // secret code Q19：请解释原型模式原型模式会创建一个新的对象，但是不会创建一个未初始化的对象，而是通过拷贝原型链上的值或被拷贝对象的值来完成初始化。传统的语言很少使用原型模式，但是js作为一个基于原型的语言，使用原型模式来创建新的对象。 Q20：判断给定的字符串是否同态首先介绍什么叫做同态：两个字符串，如果A字符串的每一个字符都可以在B字符串中找到唯一对应，并且顺序一一对应；如果存在这样的函数，那么A和B同态。 paper 和 title 同态 egg 和 sad 不同态 dgg 和 add 同态 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 isIsomorphic(&apos;egg&apos;, &apos;add&apos;); // true isIsomorphic(&apos;paper&apos;, &apos;title&apos;); // true isIsomorphic(&apos;kick&apos;, &apos;side); // false function isIsomorphic(fir, sec) &#123; if (fir.length !== sec.length) return false; var letterMap = &#123;&#125;; for(var i = 0; i &lt; fir.length; i++&gt;) &#123; var letterA = fir[i], letterB = sec[i]; if(letterMap[letterA] == undefined) &#123; letterMap[letterA] = letterB; &#125; else if (letterMap[letterA] !== letterB) &#123; return false; &#125; &#125; return true; &#125; Q21：Transpiling代表了什么意思？Transpiling 是 transforming + compiling 的合成词。对于一个新的语法，浏览器还不支持。最好的办法就是将其变换到旧的等价的代码，这个过程通常叫做 transpiling 。典型的，你可以在 build 的过程中加入 transpiler ，就如同 code linter 和 minifier 一样。 Q22：this关键字如何工作？请提供一些例子在js中，this总是指向函数的拥有者（也就是指向该函数的对象），或者拥有该函数的对象。1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function foo() &#123; console.log(this.bar); &#125; var bar = &quot;global&quot;; var obj1 = &#123; bar: &quot;obj1&quot;, foo: foo &#125;; var obj2 = &#123; bar: &apos;obj2&apos; &#125; foo(); // global obj1.foo(); // obj1 foo.call(obj2); // obj2 new foo(); // undefined Q23：如何为Array对象添加你自定义的函数，求数组平均数。1 2 3 var arr = [1, 2, 3, 4, 5]; var avg = arr.average(); // 求数组平均数 console.log(avg); js是一个基于原型的语言。也就是说对象之间通过原型链接，并集成其函数。为了给Array对象添加函数，我们可以修改其原型定义 Array prorotype 。1 2 3 4 Array.prototype.average = function() &#123; var sum = this.reduce(function(perv, cur) &#123;return prev + cur;&#125;); return sum / this.length; &#125; Q24：js中提升(hoisting)是什么意思？提升是指js的解释器将所有的变量和函数声明都提升到该作用域的顶部，有两种提升类型： 变量提升 函数提升在一个作用域中通过声明的变量和函数在整个作用域中都可以使用。 Q25：0.1 + 0.2 === 0.3返回false。因为浮点数在系统内的精确度问题，0.1 + 0.2的结果并不是0.3，而是0.30000000000000004。要避免这个问题的方法是指定返回结果的小数位数。 Q26：请描述一下揭示模式（Revealing Module Pattern）Module pattern的一个变种是Revealing Module Pattern。该设计模式的目的是做到很好的代码隔离，只是将需要对外公开的变量暴露出来。一个直接的实现如下所示：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var Exposer = (function() &#123; var privateVariable = 10; var privateMethod = function() &#123; console.log(&apos;Inside a private method!&apos;); privateVaribale++; &#125; var methodToExpose = function() &#123; console.log(&apos;This is a method I want to expose!&apos;); &#125; var otherMethodIWantToExpose = function() &#123; privateMethod(); &#125; return &#123; first: methodToExpose, second: otherMethodIWantToExpose &#125;; &#125;)(); Q27：new干了什么 新生成了一个对象 链接到原型 绑定this 返回新对象 1 2 3 4 5 6 7 8 9 10 11 12 function new() &#123; // 创建了一个空的对象 let obj = new Object() // 获得构造函数 let Con = [].shift.call(arguments) // 链接到原型 obj.__proto__ = Con.prototype // 绑定this，执行构造函数 let result = Con.apply(obj, arguments) // 确保new出来的是个对象 return typeof result === &apos;object&apos; ? result : obj &#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>前端面试系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试系列(一)]]></title>
    <url>%2F2018%2F11%2F17%2Fmianshi%2F</url>
    <content type="text"><![CDATA[前端面试系列(一) Q1:什么情况下会碰到跨域问题？有哪些解决方案 跨域问题是浏览器为了安全实施的同源策略导致的，同源策略限制了来自不同源的document、脚本，同源的意思就是两个URL的域名、协议、端口要完全相同。 script标签jsonp跨域、nginx反向代理、node.js中间件代理跨域、后端在头部信息设置安全域名、后端在服务器上设置cores。 Q2: 如何判断一个变量时对象还是数组？ 判断数组和对象分别都有好几种方法，其中用prototype.toString.call()兼容性最好。 1 2 3 4 5 6 7 8 9 function is ObjArr(value) &#123; if (Object.prototype.toString.call(value) === &quot;[Object Array]&quot;) &#123; console.log(&quot;value是数组&quot;); &#125; else if(Object.prototype.toString.call(value) === &quot;[Object Object]&quot;)&#123; // 这个方法兼容性好一点 console.log(&quot;value是对象&quot;); &#125; else &#123; console.log(&quot;value不是对象也不是数组&quot;); &#125; &#125; ps:千万不能用typeof来判断对象和数组，因为这两种类型都会返回“object”。 Q3:定时器的执行顺序或机制。 因为js是单线程的，浏览器遇到setTimeout或者setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的待执行事件队列里面，等到浏览器执行完当前代码之后会看一下事件队列里面有没有任务，有的话才会执行定时器的代码。 Q4: html中title属性和alt属性的区别： 1 2 3 4 5 1. &lt;img src=&quot;#&quot; alt=&quot;alt信息&quot; /&gt; // 1. 当图片不输出信息的时候，会显示alt信息，鼠标放上去没有信息，当图片正常读取，不会出现alt信息 2. &lt;img src=&quot;#&quot; alt=&quot;alt信息&quot; title=&quot;title信息&quot; /&gt; // 2. 当图片不输出信息的时候，会显示alt信息，鼠标放上去会出现title信息 // 当图片正常输出的时候，不会出现alt信息，鼠标放上去会出现title信息。 title属性可以用在除了base,basefont,head,html,meta,param,script和title之外的所有标签title属性的功能是提示。额外的说明信息和非本质的信息请使用title属性。title属性值可以比alt属性值设置的更长title属性有一个很好的用途，即为连接添加描述性文字，特别是当连接本身并不是十分清楚的表达了链接的目的。 Q5: ES5的继承和ES6的继承有什么区别？ ES5的继承是通过prototype或构造函数机制来实现。ES5的继承实质上试先创建子类的实例对象，然后再将父类的方法添加到this上(Parent.apply(this))。ES6的继承机制完全不同，实质上是先创建父类的实例对象this(所以必须先调用父类的super()方法)，然后再用子类的构造函数修改this。具体的：ES6通过class关键字定义类，里面有构造方法，类之间通过extends关键字实现继承。子类必须在constructor方法中调用super方法，否则新建实例报错。因为子类没有自己的this对象，而是继承了父类的this对象，然后对其进行加工。如果不调用super方法，子类得不到this对象。ps：super关键字指代父类的实例，即父亲的this对象。在子类构造函数中，调用super后，才可以使用this关键字，否则报错。 Q6：CSS3有哪些新增的属性？ 这里可以分为边框、背景，渐变，阴影，2D转换，3D转换等。 Q7: 你知道哪些http状态码？ 1xx: 1开头的是信息状态码2xx: 2开头的是请求成功3xx: 3开头的是重定向4xx: 4开头的是客户端错误 400：请求无效产生原因： 前端提交数据的字段名和字段类型与后台的实体没有保持一致 前端提交到后台的数据应该是json字符串类型，但是前端没有将对象JSON.stringify转化成字符串。 401: 当前请求需要用户验证 403：服务器已经得到请求，但是拒绝执行。 5xx: 5开头的是服务器错误 Q8: 如何对一个数组去重？ Set解构去重。这是ES6提供了新的数据结构Set。它类似于数组，但是会自动去重。 1 2 let unique = [... new Set(array)]; // Set内部使用===来判断是否相等，&apos;1&apos;和1都会保存，NaN和NaN只会保存一个。 遍历，将值添加到新数组，用indexOf()判断值是否存在，已存在就不添加，达到去重效果 1 2 3 4 5 6 7 8 9 10 11 12 let a = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,1,NaN,NaN,undefined,undefined,null,null,&apos;a&apos;,&apos;b&apos;,&apos;b&apos;]; let unique = arr =&gt; &#123; let newA = []; arr.forEach(key =&gt; &#123; if (newA.indexOf(key) &lt; 0)&#123; newA.push(key); &#125; &#125;); return newA; &#125; console.log(unique(a));//[&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,1,NaN,NaN,undefined,null,&apos;a&apos;,&apos;b&apos;] // ps:这个方法不能分辨NaN，会出现两个NaN。是有问题的，下面的好一点。 遍历，将数组的值添加到一个对象的属性名里，并给属性赋值，对象不能添加相同属性名，以这个为依据可以实现数组去重，然后用Object.key(对象)返回这个对象可枚举属性组成的数组，这个数组就是去重后的数组。 1 2 3 4 5 6 7 8 9 let a = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,1,NaN,NaN,undefined,undefined,null,null,&apos;a&apos;,&apos;b&apos;,&apos;b&apos;]; const unique = arr =&gt; &#123; var obj = &#123;&#125;; arr.forEach(value =&gt; &#123; obj[value] = 0; // 这步添加一个属性，并赋值，如果不赋值，属性添加不上去。 &#125;) return Object.keys(obj); &#125; console.log(unique(a));//[&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,1,NaN,undefined,null,&apos;a&apos;,&apos;b&apos;] 注意：这个方法会将number，NaN，undefined，null变为字符串形式，因为对象的属性名就是一个字符串，根据需求来吧，想象还是Set去重最简单也最有效。 Q9: 垂直居中有哪些方法？ 单行文本的话可以使用height和line-height设置同一高度。 position+margin(定高)：设置父元素：position:relative;，子元素height: 100px;position:absolute;top:50%;margin:-50px 0 0 0; position+transform(不定高): 设置父元素position:relatice，子元素：position:absolute;top:50%;transform: translate(0,-50%); 百搭flex布局(ie10+)(不定高)：设置父元素display:flex;align-items:center Q10:翻转一个字符串 思路是先将字符串转成一个数组，然后用数组的reverse()+join()方法。1 2 let str = &quot;hello word&quot;; let b = [...str].reverse().join(&quot;&quot;);// drow olleh Q11: 了解ES6的let和const变量声明吗？跟ES5的var有哪些区别？ let 在同一个作用域里面： var可以重复声明变量，let不能重复声明同一变量。ES5是函数作用域，即一个函数里面才是一个作用域。ES6是块级作用域，花括号里面就是一个作用域。 var有变量提升，可以在变量声明之前使用，let不存在变量提升，在变量之前使用会报错。 let有暂时性死区，即父作用域中有var定义，在块作用域里又定义了let，那在块let之前使用，就是死区。 const const的很多特性跟let的特性一样，都有：不可重复声明，不存在变量提升，有暂时性死区，都是块级作用域。 和let不一样的地方：const必须在声明的时候赋值，不然会报错。const声明的常量不能更改。值引用是完全不能更改，引用类型，const只能保证指针是固定的。 Q12: 继承函数对象的实例方法、原型的继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function father(name) &#123; // 父函数 this.name = name||&apos;lionel&apos;; this.code = function() &#123; // 父函数的实例方法 console.log(this.name + &apos;coding&apos;); &#125; &#125;; father.prototype.add = function(food) &#123; // 父函数的原型方法 console.log(this.name + &apos;eat&apos; + food); &#125; function son(name) &#123; // 子函数 father.call(this); // 将this绑定到子类，绑定父类的实例方法code(原型方法还未绑定) this.name = name || &apos;lionel1&apos;; &#125; son.prototype = new father(); // 把父函数的原型方法绑定到子类，实现继承 var sonVar = new son(&apos;faker&apos;); // 这里也可以传参name son.prototype.constructor = son; // 修复构造函数的指向 console.log(sonVar.code()); console.log(sonVar.add()); // 可以调用父类的方法了 Q13: 通过reduce函数来实现简单的数组求和，示例数组[3, 4, 8, 0, 9] 三种方法，一种是常见的遍历方法，另一种是eval()方法，还有一种是reduce()函数1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 第一种常规遍历 let reduce = (arr) =&gt; &#123; let num = 0; for (let [index, value] of arr.entries())&#123; num += value; &#125; return num; &#125; // 第二种 let reduce = (arr) =&gt; eval(arr.join(&quot;+&quot;)); // 第三种 let result = [3, 4, 8, 0, 9].reduce((total, value) =&gt; &#123; return total + value &#125;) Q14: call()和apply()有什么区别？ call()和apply()第一个参数将用作函数内this的值，用于改变函数的this执行。区别在于，call()方法接收逗号分隔的参数作为后面的参数，apply()接收一个参数数组作为后面的参数，可以从apply联想到array。 Q15: position有哪些值？有什么作用？ static：默认值，不脱离文档流，top，right，bottom，left等属性不生效。 relative：不脱离文档流，依据自身位置进行偏离，当子元素设置absolute，将依据它进行偏离。 absolute：脱离文档流，依据top，right，bottom，left等属性在正常文档流中偏移位置。 fixed：通过浏览器窗口进行定位，出现滚动条的时候，不会随之滚动。 Q16: 如何实现一个闭包？闭包的作用有哪些？ 在一个函数里面嵌套另一个函数，被嵌套的那个函数的作用域是一个闭包。 作用： 创建私有变量，减少全局变量，防止变量名污染。可以操作外部作用域的变量，变量不会被浏览器回收，保存变量的值。 Q17: 请从2018-11-16T15:13Europe/Paris提取出结果[&#39;2018&#39;,&#39;11&#39;,&#39;16&#39;,&#39;15&#39;,&#39;13&#39;] 写一个只获取数字的正则表达式就行了。1 2 3 4 5 let str = &apos;2018-11-16T15:13Europe/Paris&apos;; let arr = str.match( /\d&#123;1,&#125;/g ); // \d 查找数字 // &#123;1,&#125;表示至少重复几次 // /g表示全局搜索 Q18:请描述一下promise的使用场景，它所解决的问题以及现在对于异步操作的解决方案。 promise的使用场景：ajax请求、回调函数、复杂操作判断。promise是ES6为了解决异步编程所诞生。异步操作的解决方案：promise、generator、ES7的async。 Q19: Vuex的工作流程，以及它的作用，使用场景。 Vuex工作流程： 在vue组件里面，通过dispatch来触发actions，提交修改数据的操作。 然后在通过actions的commit来触发mutations，修改数据。 mutations接收到commit的请求，就会自动通过Mutate来修改state里面的数据。 最后store触发每一个调用它的组件的更新 Vuex的作用：项目数据状态的集中管理，复杂组件（如兄弟组件、远方亲戚组件）的数据通信问题。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>前端面试系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2018%2F11%2F17%2FHello-Hexo%2F</url>
    <content type="text"><![CDATA[本地hexo server || hexo s上传hexo clean &amp;&amp; hexo g &amp;&amp; hexo d Hexo-admin插件允许我们直接在本地页面上修改文章内容。npm i hexo-admin --save本地修改 http://localhost:4000/admin 新建页面 hexo new &quot;pageName&quot;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1 $ hexo new "My New Post" More info: Writing Run server1 $ hexo server More info: Server Generate static files1 $ hexo generate More info: Generating Deploy to remote sites1 $ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
